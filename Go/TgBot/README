# 1. Запустить БД в Docker
docker-compose up -d

# 2. Запустить приложение локально
go run cmd/main.go

# 3. Запустить приложение
docker-compose up -d && go run cmd/main.go

	/*//const MethodGetMe = "getMe"
	body := domain.GetBodyByUrl(domain.GetUrlByMethod("/start"))
	start := domain.MessageT{}
	err := json.Unmarshal(body, &start)
	if err != nil {
		fmt.Printf("Error in unmarshal: %s", err.Error())
		return
	}
	fmt.Println("%v", start)
	// Подключаемся к БД
	log.Println("Connecting to database...")
	body := domain.GetBodyByUrl(domain.GetUrlByMethod("/start"))
	start := storage.Start(body){}
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	log.Println("Connected to database")

	// Создаем репозиторий PostgreSQL
	listRepo := postgres.NewListRepo(pool)*/

    кусок недоделанный func main() {
	cfg := domain.Load()
	log.Printf("Конфигурация загружена: БД=%s:%s", cfg.DBHost, cfg.DBPort)
	log.Println("Бот загружен и готов к работе")

	lastUpdateID := 0

	for {
		apiUrl := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage?offset=%d&timeout=10", botToken, lastUpdateID+1)

		response, err := http.Get(apiUrl)
		if err != nil {
			log.Printf("Ошибка")
			time.Sleep(2 * time.Second)
			continue
		}

		body, _ := io.ReadAll(response.Body)
		response.Body.Close()

		var result map[string]interface{}
		json.Unmarshal(body, &result)

		body, err := io.ReadAll(response.Body)
		if err != nil {
			log.Fatal("Ошибка чтения ответа")
		}

		log.Printf("Статус: %d", response.StatusCode)
		log.Printf("Ответ: %s", string(body))

		if response.StatusCode == 200 {
			log.Println("Сообщение отправлено успешно")
		} else {
			log.Println("Ошибка")
		}
	}
}

func sendMassage(token, chatId, messageText string) {
	apiUrl := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", token)
	params := url.Values{}
	params.Add("chat_id", chatId)
	params.Add("text", messageText)

	fullURL := apiUrl + "?" + params.Encode()

	resp, _ := http.Get(fullURL)
	defer resp.Body.Close()

	log.Printf("Отправлено, %s", text)
}